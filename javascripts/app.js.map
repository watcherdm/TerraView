{"version":3,"file":"public/javascripts/app.js","sources":["app/application.coffee","app/initialize.coffee","app/lib/utils.coffee","app/models/Heightmap.coffee","app/models/HeightmapChunk.coffee","app/models/Tile.coffee","app/models/Viewport.coffee","app/models/base/Model.coffee","app/views/Stage.coffee","app/views/Tile.coffee","app/views/TileMap.coffee","app/views/Viewport.coffee","app/views/base/View.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArIA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxFA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/CA;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA","sourcesContent":["StageView = require \"views/Stage\"\n\nmodule.exports = class Application\n  initialize: ->\n    canvasEl = document.getElementById \"main-canvas\"\n\n    StageView.create canvasEl\n\n    document.onkeydown = @onKeyDown\n\n  onKeyDown: (event) ->\n    EventBus.dispatch \"!key:down\", @, event\n","Application = require 'application'\n\nwindow.onload = ->\n  (new Application).initialize()\n","module.exports = utils =\n  seed: +new Date\n\n  clamp: (index, size) ->\n    (index + size) % size\n\n  random: (seed) ->\n    new RNG(seed).uniform()\n\n  tileHeightToType: (height, maxElevation) ->\n    if height / maxElevation >= 0.5\n      type = 1\n    else\n      type = 0\n\n    type\n","Model = require \"models/base/Model\"\nutils = require \"lib/utils\"\nHeightmapChunkModel = require \"models/HeightmapChunk\"\n\nmodule.exports = Model.extend \"HeightmapModel\",\n  {\n    create: (seed, worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation) ->\n      model = @_super()\n\n      model.worldTileWidth = worldChunkWidth * chunkWidth\n      model.worldTileHeight = worldChunkHeight * chunkHeight\n\n      model.chunks = @buildChunks seed, worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation, model.worldTileWidth, model.worldTileHeight\n\n      model.heightmap = @generateHeightmap model.chunks, maxElevation\n\n      model.data = @processTiles model.heightmap, model.worldTileWidth, model.worldTileHeight\n\n      model\n\n    processTiles: (heightmap, xl, yl) ->\n      data = []\n\n      cx = (x) -> utils.clamp x, xl\n      cy = (y) -> utils.clamp y, yl\n\n      for y in [0..yl - 1]\n        data[y] = []\n\n        for x in [0..xl - 1]\n          n = heightmap[cy y - 1][x]\n          e = heightmap[y][cx x + 1]\n          s = heightmap[cy y + 1][x]\n          w = heightmap[y][cx x - 1]\n          ne = heightmap[cy y - 1][cx x + 1]\n          se = heightmap[cy y + 1][cx x + 1]\n          sw = heightmap[cy y + 1][cx x - 1]\n          nw = heightmap[cy y - 1][cx x - 1]\n\n          o = heightmap[y][x]\n\n          if o is 0\n            s = 0\n          else\n            a = n << n * 4\n            b = e << e * 5\n            c = s << s * 6\n            d = w << w * 7\n            e = ne << ne * 0\n            f = se << se * 1\n            g = nw << nw * 3\n            h = sw << sw * 2\n\n            s = a + b + c + d + e + f + g + h\n\n          heightmapTile = s\n\n          data[y][x] = heightmapTile\n\n      data\n\n    generateHeightmap: (chunks, maxElevation) ->\n      heightmap = []\n\n      for chunkRow, y in chunks\n        for chunk, x in chunkRow\n          cells = chunk.cells\n\n          for cellRow, cy in cells\n            for cell, cx in cellRow\n              yIndex = cy + (y * cells.length)\n              xIndex = cx + (x * cellRow.length)\n\n              heightmap[yIndex] = [] unless heightmap[yIndex]?\n              heightmap[yIndex][xIndex] = utils.tileHeightToType cell, maxElevation\n\n      heightmap\n\n    buildChunks: (seed, worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation, worldTileWidth, worldTileHeight)->\n      chunks = []\n\n      for y in [0..worldChunkHeight - 1]\n        chunks[y] = []\n\n        for x in [0..worldChunkWidth]\n          nw = utils.random(y * worldTileWidth + x + seed) * maxElevation\n\n          if x + 1 is worldChunkWidth\n            ne = utils.random(y * worldTileWidth + seed) * maxElevation\n          else\n            ne = utils.random(y * worldTileWidth + x + 1 + seed) * maxElevation\n\n          if y + 1 is worldChunkWidth\n            sw = utils.random(x + seed) * maxElevation\n\n            if x + 1 is worldChunkHeight\n              se = utils.random(seed) * maxElevation\n            else\n              se = utils.random(x + 1 + seed) * maxElevation\n          else\n            sw = utils.random((y + 1) * worldTileWidth + seed) * maxElevation\n\n            if x + 1 is worldChunkWidth\n              se = utils.random((y + 1) * worldTileWidth + seed) * maxElevation\n            else\n              se = utils.random((y + 1) * worldTileWidth + x + 1 + seed) * maxElevation\n\n          chunks[y][x] = HeightmapChunkModel.create nw, ne, se, sw, chunkWidth, chunkHeight\n\n      chunks\n  }, {\n    getArea: (sliceWidth, sliceHeight, centerX, centerY) ->\n      data = []\n\n      heightmapData = @data\n\n      xOffset = sliceWidth >> 1\n      yOffset = sliceHeight >> 1\n\n      for y in [0..sliceHeight - 1]\n        data[y] = []\n\n        for x in [0..sliceWidth - 1]\n          xIndex = utils.clamp x - xOffset + centerX, @worldTileWidth\n          yIndex = utils.clamp y - yOffset + centerY, @worldTileHeight\n\n          data[y][x] = heightmapData[yIndex][xIndex]\n\n      data\n  }\n","Model = require \"models/base/Model\"\n\nmodule.exports = Model.extend \"HeightmapChunkModel\",\n  {\n    create: (args...) ->\n      model = @_super()\n\n      model.cells = @bilinearInterpolate args...\n\n      model\n\n    bilinearInterpolate: (nw, ne, se, sw, width, height) ->\n      xLookup = []\n      cells = []\n\n      for y in [0..height - 1]\n        cells[y] = []\n        yStep = y / (height - 1)\n\n        for x in [0..width - 1]\n          if xLookup[x]?\n            xStep = xLookup[x]\n          else\n            xStep = xLookup[x] = x / (width - 1)\n\n          topHeight = nw + xStep * (ne - nw)\n          bottomHeight = sw + xStep * (se - sw)\n          cellHeight = topHeight + yStep * (bottomHeight - topHeight)\n          cells[y][x] = ~~cellHeight\n\n      cells\n  }, {\n  }\n","Model = require \"models/base/Model\"\n\nmodule.exports = Model.extend \"TileModel\",\n  {\n    create: (index, x, y) ->\n      model = @_super()\n\n      model.index = index\n      model.x = x\n      model.y = y\n\n      model\n  }, {\n    setIndex: (index) ->\n      if @index isnt index\n        @index = index\n\n        @onChangeIndex()\n\n    setIndexCallback: (callback) ->\n      @onChangeIndex = callback\n\n    onChangeIndex: ->\n  }\n","Model = require \"models/base/Model\"\n\nmodule.exports = Model.extend \"ViewportModel\",\n  {\n    create: (x, y, width, height, worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation) ->\n      model = @_super()\n\n      model.x = x\n      model.y = y\n      model.width = width\n      model.height = height\n      model.worldChunkWidth = worldChunkWidth\n      model.worldChunkHeight = worldChunkHeight\n      model.chunkWidth = chunkWidth\n      model.chunkHeight = chunkHeight\n      model.maxElevation = maxElevation\n\n      model.worldTileWidth = chunkWidth * worldChunkWidth\n      model.worldTileHeight = chunkHeight * worldChunkHeight\n\n      model\n  }, {\n    setX: (x) ->\n\n      if x isnt @x\n        @x = x\n        EventBus.dispatch \"!viewport:move\", @, x\n\n    setY: (y) ->\n      if y isnt @y\n        @y = y\n        EventBus.dispatch \"!viewport:move\", @, y\n  }\n","module.exports = gamecore.DualPooled.extend \"Model\",\n  {\n    getUsedLength: ->\n      @getPool().usedList.length()\n  }, {\n    dispose: ->\n      @release()\n  }\n","View = require \"views/base/View\"\nViewportModel = require \"models/Viewport\"\nViewportView = require \"views/Viewport\"\n\nmodule.exports = View.extend \"StageView\",\n  {\n    create: (canvasEl) ->\n      view = @_super()\n\n      view.el = new createjs.Stage canvasEl\n\n      view.viewportModel = ViewportModel.create 0, 0, 30, 20, 8, 8, 8, 8, 10\n      view.viewportView = ViewportView.create view.viewportModel\n      view.el.addChild view.viewportView.el\n\n      view.el.update()\n\n      _.bindAll view, \"onTick\"\n\n      createjs.Ticker.setFPS 60\n      createjs.Ticker.useRAF = true\n\n      createjs.Ticker.addEventListener \"tick\", view.onTick\n\n      view\n  }, {\n    onTick: ->\n      @el.update()\n\n    dispose: ->\n      createjs.Ticker.removeEventListener \"tick\", @onTick\n\n      @viewportView.dispose()\n      @viewportModel.dispose()\n\n      @_super()\n  }\n","View = require \"views/base/View\"\n\nmodule.exports = View.extend \"TileView\",\n  {\n    create: (tileModel) ->\n      view = @_super()\n\n      view.model = tileModel\n\n      view.el = new createjs.Bitmap \"images/tileset_terra.png\"\n\n      view.model.setIndexCallback ->\n        view.setSpritePosition()\n\n      view.setSpritePosition()\n\n      view\n  }, {\n    setSpritePosition: ->\n      index = @model.index\n      x = (index % 16)\n      y = ~~(index / 16)\n\n      @el.sourceRect = new createjs.Rectangle x * 16, y * 16, 16, 16\n  }\n","View = require \"views/base/View\"\nHeightmapModel = require \"models/Heightmap\"\nTileModel = require \"models/Tile\"\nTileView = require \"views/Tile\"\nutils = require \"lib/utils\"\n\nmodule.exports = View.extend \"TileMapView\",\n  {\n    create: (viewportModel) ->\n      view = @_super()\n\n      view.el = new createjs.Container\n\n      view.model = viewportModel\n\n      view.heightmap = HeightmapModel.create utils.seed, viewportModel.worldChunkWidth, viewportModel.worldChunkHeight, viewportModel.chunkWidth, viewportModel.chunkHeight, viewportModel.maxElevation;\n\n      view.tileModels = @buildTileModels view\n\n      view.tileViews = @buildTileViews view\n\n      _.each view.tileViews, (tileView) -> view.el.addChild tileView.el\n\n      view.el.addChild(tileView.el) for tileView in view.tileViews\n\n      EventBus.addEventListener \"!viewport:move\", view.drawMap, view\n\n      view\n\n    buildTileViews: (view) ->\n      views = []\n\n      _.each view.tileModels, (tileModel) ->\n        tileView = TileView.create tileModel\n\n        tileView.el.x = tileModel.x * 16 # TODO no magic numbers\n        tileView.el.y = tileModel.y * 16\n\n        views.push tileView\n\n      views\n\n    buildTileModels: (view) ->\n      heightmap = view.heightmap\n      model = view.model\n      heightmapData = heightmap.getArea model.width, model.height, model.x, model.y\n\n      tiles = []\n\n      for y in [0..heightmapData.length - 1]\n        for x in [0..heightmapData[y].length - 1]\n          tileModel = TileModel.create heightmapData[y][x], x, y\n\n          tiles.push tileModel\n\n      tiles\n  }, {\n    drawMap: ->\n      heightmapData = @heightmap.getArea @model.width, @model.height, @model.x, @model.y\n\n      for y in [0..heightmapData.length - 1]\n        for x in [0..heightmapData[y].length - 1]\n          tileModel = @tileModels[x + heightmapData[y].length * y]\n\n          tileModel.setIndex heightmapData[y][x]\n\n    dispose: ->\n      @heightmap.dispose()\n\n      _.each @tileModels, (tileModel) ->\n        tileModel.dispose()\n\n      _.each @tileViews, (tileView) ->\n        tileView.dispose()\n\n      EventBus.removeEventListener \"!viewport:move\", @drawMap, @\n\n      @_super()\n  }\n","View = require \"views/base/View\"\nTileMapView = require \"views/TileMap\"\nutils = require \"lib/utils\"\n\nmodule.exports = View.extend \"ViewportView\",\n  {\n    create: (viewportModel) ->\n      view = @_super()\n\n      view.model = viewportModel\n\n      view.el = new createjs.Container\n\n      view.tileMapView = TileMapView.create viewportModel\n\n      view.el.addChild view.tileMapView.el\n\n      EventBus.addEventListener \"!key:down\", view.onKeyDown, view\n\n      view\n  }, {\n    onKeyDown: (_event, args) ->\n      switch args.keyCode\n        when 37\n          x = @model.x - 1\n          x = utils.clamp x, @model.worldTileWidth\n          @model.setX x\n        when 38\n          y = @model.y - 1\n          y = utils.clamp y, @model.worldTileHeight\n          @model.setY y\n        when 39\n          x = @model.x + 1\n          x = utils.clamp x, @model.worldTileWidth\n          @model.setX x\n        when 40\n          y = @model.y + 1\n          y = utils.clamp y, @model.worldTileHeight\n          @model.setY y\n\n    dispose: ->\n      EventBus.removeEventListener \"!key:down\", @onKeyDown, @\n\n      @tileMapView.dispose()\n\n      @_super()\n  }\n","module.exports = gamecore.DualPooled.extend \"View\",\n  {\n    getUsedLength: ->\n      @getPool().usedList.length()\n  }, {\n    dispose: ->\n      @release()\n  }\n"]}